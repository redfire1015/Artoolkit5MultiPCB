/*		Virtual Prototyping for Power Electronics
 *
 * 		@file:				standAloneSolve.c
 * 		Author(s): 			P L Evans
 * 		Creation Date:		18/03/2020
 *
 * 		Description:	    Solvers that don't depend on the solve wrapper.
 *
 */

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef VPPE3_STANDALONESOLVE_H
#define VPPE3_STANDALONESOLVE_H

#include "msolve.h"

	/** GMRES Solver.
	 * Can be used outside of the MS_Solver wrapper.
	 * @param A is A in Ax = b
	 * @param B is b in Ax = b
	 * @param x0 is x in Ax = b and also the initial guess for the iterations. It is important that this is not zero! A unit vector [1,0,0,0,...] tends to work well.
	 * @param maxIts is the maximum number of iterations that will be attempted. Set to dimension of A for guaranteed solution. Set through params passed to MS_initSolver(), MS_modifyLHS() and MS_changeLHS().
	 * @param tol is the convergence tolerance. 1e-6 tends to work well. Set through params passed to MS_initSolver(), MS_modifyLHS() and MS_changeLHS()
	 * @return 1 for success, 0 for fail.
	 */
	ML_INT gmres(spMATRIX* A, double* B, double* x0, ML_INT maxIts, double tol);


	/** Preconditioned GMRES Solver.
	 * Can be used outside of the MS_Solver wrapper.
	 * @param A is A in Ax = b
	 * @param M is the sparse LU preconditioner generated by [TODO: NEEDS A STANDALOND ILUT FUNCTION!]
	 * @param uptr is the index of the diagonals in M, generated by [TODO: NEEDS A STANDALOND ILUT FUNCTION!]
	 * @param B is b in Ax = b
	 * @param x0 is x in Ax = b and also the initial guess for the iterations. It is important that this is not zero! A unit vector [1,0,0,0,...] tends to work well.
	 * @param maxIts is the maximum number of iterations that will be attempted. Set to dimension of A for guaranteed solution. Set through params passed to MS_initSolver(), MS_modifyLHS() and MS_changeLHS().
	 * @param tol is the convergence tolerance. 1e-6 tends to work well. Set through params passed to MS_initSolver(), MS_modifyLHS() and MS_changeLHS()
	 * @return 1 for success, 0 for fail.
	 */
	ML_INT gmresp(spMATRIX* A, spMATRIX* M, ML_INT* uptr, double* B, double* x0, ML_INT maxIts, double tol);


	/** LU solver used to solve Ax = b where A is a matrix that has been factored by MS_getILUT.
	 * ONLY USED INTERNALLY BY MS_gmres() or MS_gmresp()
	 * @param M contains the LU factors
	 * @param uptr contains the diagonal indces of M
	 * @param b is b in Ax = b
	 * @param x is x is Ax = b (the solution)
	 */
	ML_INT MS_LUSolve(spMATRIX* M, ML_INT* uptr, double* b, double* x);


	/**  Partial LU factorisation with controlled fill-in
	 *
	 * @param A matrix to factor
	 * @param M factored output matrix
	 * @param uptr index of diagonals (output, allocated to A->nr on input)
	 * @param t threshold parameter to control fill-in
	 * @return 0 on fail, 1 on success
	 */
	ML_INT getILUT(spMATRIX* A, spMATRIX* M, ML_INT* uptr, double t);

#endif //VPPE3_STANDALONESOLVE_H

#ifdef __cplusplus
}
#endif
